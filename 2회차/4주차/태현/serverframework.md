# 서버 프레임워크

## 서버 프레임워크

웹 백엔드 프레임워크(ex. node.js) 같이 서버 개발을 할 때 재활용 가능한 형태로 클래스를 제공하는 틀이다. 서버 프레임워크를 사용하면 새로운 서버를 개발할 때마다 구조를 처음부터 다시 짜지 않아도 된다.

## 구조

게임서버는 단순히 웹처럼 http통신처럼 Reques, Response구조가 아니라 ‘패킷’이라는 형태로 메세지를 관리한다(웹소켓을 사용하면 http통신에서 서버와 클라이언트가 능동적으로 통신이 가능).

언어가 다르다고 하더라도 기본적인 구조는 크게 다르지 않다.

### 주요 클래스

- **Session**
    - 접속한 대상에 대한 대리자 역할을 한다. *-옵저버패턴*
    - 서버를 개발할 때 이 클래스를 상속해 등록해 사용한다.
    - 콜백 메소드
        - On connected : 접속되었을 때
        - On disconnected : 연결끊겼을 때
        - On receive : 수신했을 때
        - On send : 송신완료했을 때 - 선택적
- **Server(Service)**
    - 클라이언트가 접속하는 입구 역할을 한다.
    - Session Factory에 Session의 파생 클래스를 생성하는 함수객체(함수자;Functor) 또는 구현 구문을 넣어준다. *-팩토리패턴*
        - 클라이언트가 접속하면 넣어준 Session의 파생 클래스의 객체가 생성된다.
- **Client(Service)**
    - 지정한 엔드포인트(IP주소 + 포트번호)로 연결을 시도한다.
    - ServerService와 같이 Session Factory에 Session클래스의 파생클래스를 넣어준다.
        - 서버에 접속이 성공하면 넣어준 Session의 파생 클래스의 객체가 생성된다.
- **JobSerializer** - 선택적
    - 멀티스레드 서버의 경우 락을 사용했을 때 병목현상이 일어나기 때문에 스레드에 각자가 할 일을 분배해 서로 접근하지 못하게 만들어 락을 쓰지 않아도 되게 된다.
    - 레드존(데이터레이스 발생 가능성 있는 지역)에서 직접 메소드를 실행하지 않고, Launch에서 메소드 실행에 대한 정보(메소드와, 메소드 안에 들어갈 인자)를 넣는다.
        
        ```cpp
        /* 예제코드
        &Room::EnterRoom : 메소드의 주소
        나머지 인수 : EnterRoom에 들어갈 인수
        
        결과 : room객체 내부에서 EnterRoom(session, player)에 대한 함수자가 저장된다.
        */
        room->Launch(&Room::EnterRoom, session, player);
        ```
        
        이 정보(EnterRoom(session, player))는 바로 실행되지 않고 전역 큐에 담기게 되고, 각각의 스레드가 지정된 작업을 담당해 실행된다.
        
    - 위에서 예를 든 EnterRoom의 경우 한 스레드만 접근하게 되므로 락을 쓰지 않고 개발할 수 있게 된다.